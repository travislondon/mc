/*----------------------------------------------------------------------------
 * File:  sys_user_co.c
 *
 * Description:
 * Interface call-outs allow the user to capture execution control of the
 * generated system running on a target.
 * Especially in the deeply embedded software/hardware development world,
 * it may be necessary to tightly interface the xtUML system to the
 * surrounding/containing system. MC-3020 provides callout routines
 * that enable the user to easily interface code generated by the model
 * compiler with other system code. These callout routines are empty when
 * generated by the model compiler. It is up to the user to define
 * additional functionality (if necessary) to be performed at these
 * callout points.
 *--------------------------------------------------------------------------*/

#include "masl_sys_types.h"
#include "masl_genfile_class.h"
#include "T_bridge.h"
#include "sys_user_co.h"

#ifdef SYS_USER_CO_PRINTF_ON
#include <stdio.h>
#define SYS_USER_CO_PRINTF( s ) printf( s );
#else
#define SYS_USER_CO_PRINTF( s )
#endif

// we write our own implementation of strsep so it works on windows
#include <string.h>
char *_strsep(char **stringp, const char *delim) {
    if ( !stringp || !*stringp ) return NULL;
    char* start = *stringp;
    char* p = strpbrk( start, delim );
    if ( !p ) {
        *stringp = NULL;
    }
    else {
        *p = '\0';
        *stringp = p+1;
    }
    return start;
}

#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <ctype.h>
#include "masl_url.h"
#ifndef WIN
#include <execinfo.h>
#endif
#include <signal.h>
void masl_sig_handler(int sig) {
  void *array[10];
  size_t size;

  // get void*'s for all entries on the stack
#ifndef WIN
  size = backtrace(array, 10);
#endif

  // print out all the frames to stderr
  fprintf(stderr, "Error: signal %d:\n", sig);
#ifndef WIN
  backtrace_symbols_fd(array, size, STDERR_FILENO);
#endif
  exit(1);
}

/*
 * UserInitializationCallout
 *
 * This function is invoked at the immediate beginning of application
 * initialization. It is the very first function to be executed at system
 * startup.
 * User supplied implementation of this function should be restricted to
 * things like memory initialization, early hardware duties, etc.
 */
void
UserInitializationCalloutf( void )
{
/* Activate this invocation to initialize the example simple TIM.  */
  #if ESCHER_SYS_MAX_XTUML_TIMERS > 0
  TIM_init();
  #endif
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserInitializationCallout\n" )
}

/*
 * UserPreOoaInitializationCallout
 *
 * This function is invoked immediately prior to executing any xtUML
 * initialization functions.
 */
void
UserPreOoaInitializationCalloutf( void )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserPreOoaInitializationCallout\n" )
}

/*
 * UserPostOoaInitializationCallout
 *
 * This function is invoked immediately after executing any xtUML
 * initialization functions.
 * When this callout function returns, the system dispatcher will allow the
 * xtUML application analysis state models to start consuming events.
 */
void
UserPostOoaInitializationCalloutf( int argc, char ** argv )
{
  char s[ ESCHER_SYS_MAX_STRING_LEN ], v[ 8 ][ 64000 ];
  char * p, * q, * element, * value[8] = {v[0],v[1],v[2],v[3],v[4],v[5],v[6],v[7]};
  T_clear();
  signal(SIGSEGV, masl_sig_handler);  // segfault
  signal(SIGINT, masl_sig_handler);   // cntl-c
  while ( ( p = fgets( s, ESCHER_SYS_MAX_STRING_LEN, stdin ) ) != NULL ) {
    int i, j;
    i = 0;
    p[ strlen(p) - 1 ] = 0;
    if ( ( q = _strsep( &p, "," ) ) != NULL ) element = Escher_strcpy( element, q );
    while ( ( q = _strsep(&p, ",")) != NULL ) {
        masl_url_decode( value[ i ], q );
        i++;
    }
    masl_in_populate( element, value );
  }

  int validate = 0; int Validateonly = 0; bool coverage = FALSE; bool structuralOnly = FALSE;
  char * indirname = 0; char * outdirname = 0; char * projectdomain = 0;
  char * architecture = "MASL";
  int namecount = 0; char name[8][1024] = {0,0,0,0,0,0,0,0};
  {
    int c;
    opterr = 0;
    while ( ( c = getopt ( argc, argv, "cvVsa:i:o:d:p:" ) ) != -1 ) {
      switch ( c ) {
        case 'c':
          coverage = TRUE; break;
        case 'v':
          validate = 1; break;
        case 'V':
          Validateonly = 1; break;
        case 's':
          structuralOnly = TRUE; break;
        case 'a':
          if ( !optarg ) abort();
          architecture = optarg; break;
        case 'i':
          if ( !optarg ) abort();
          else indirname = optarg;
          break;
        case 'o':
          if ( !optarg ) abort();
          else outdirname = optarg;
          break;
        case 'd':
          if ( !optarg ) abort();
          else strncpy( name[ namecount++ ], optarg, 1024 );
          projectdomain = "domain";
          break;
        case 'p':
          if ( !optarg ) abort();
          else strncpy( name[ namecount++ ], optarg, 1024 );
          projectdomain = "project";
          break;
        case '?':
          if ( 'o' == optopt ) {
            fprintf( stderr, "Option -%c requires an argument.\n", optopt );
          } else if ( isprint (optopt) ) {
            fprintf( stderr, "Unknown option `-%c'.\n", optopt );
          } else {
            fprintf( stderr, "Unknown option character `\\x%x'.\n", optopt );
          }
        default:
          abort (); // die ignominiously
      }
    }
  }
  if ( validate || Validateonly ) {
    masl_gen_validate( "" );
  }
  if ( ! Validateonly ) {
    if ( indirname ) {
      masl_genfile_op_infolder( indirname );
    }
    if ( outdirname ) {
      masl_genfile_op_outfolder( outdirname );
    }
    if ( projectdomain ) {
      int i = 0;
      while ( i < namecount )
        masl_gen_render( architecture, projectdomain, name[ i++ ], (const bool)structuralOnly );
    } else {
      masl_gen_render( architecture, "project", "", (const bool)structuralOnly );
      masl_gen_render( architecture, "domain", "", (const bool)structuralOnly );
    }
  }
  if ( coverage ) {
    masl_gen_coverage();
  }
  exit(0);
}


/*
 * UserBackgroundProcessingCallout
 *
 * This function is invoked once during each loop execution of the system
 * dispather.
 * It is invoked at the 'top' of the system dispatcher loop, immediately
 * prior to dispatching any xtUML application analysis events.
 */
void
UserBackgroundProcessingCalloutf( void )
{
  /* Activate this invocation to periodically tick the example simple TIM.  */
  #if ESCHER_SYS_MAX_XTUML_TIMERS > 0
  TIM_tick();
  #endif
  /* Insert implementation specific code here.  */
}

/*
 * UserPreShutdownCallout
 *
 * This function is invoked at termination of the system dispatcher, but
 * prior to performing any xtUML application analysis shutdown sequencing.
 */
void
UserPreShutdownCalloutf( void )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserPreShutdownCallout\n" )
}

/*
 * UserPostShutdownCallout
 *
 * This function is invoked immediately before application exit.
 */
void
UserPostShutdownCalloutf( void )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserPostShutdownCallout\n" )
}

/*
 * UserEventCantHappenCallout
 *
 * This function is invoked any time that an event is received that
 * results in a "cant happen" transition.
 */
void
UserEventCantHappenCalloutf(
  const Escher_StateNumber_t current_state,
  const Escher_StateNumber_t next_state,
  const Escher_EventNumber_t event_number )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserEventCantHappenCallout\n" )
}

/*
 * UserEventNoInstanceCallout
 *
 * This function is invoked when we failed to validate the instance
 * to which an event was directed.  This can happen in normal operation
 * when the instance was deleted while the event was in flight (analysis
 * error).
 */
void
UserEventNoInstanceCalloutf(
  const Escher_EventNumber_t event_number )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserEventNoInstanceCallout\n" )
}

/*
 * UserEventFreeListEmptyCallout
 *
 * This function is invoked when an attempt is made to allocate an
 * event, but there are no more left.
 */
void
UserEventFreeListEmptyCalloutf( void )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserEventFreeListEmptyCallout\n" )
}

/*
 * UserEmptyHandleDetectedCallout
 *
 * This function is invoked when an attempt is made to use an instance
 * reference variable (handle) that is null (empty).
 */
void
UserEmptyHandleDetectedCalloutf( c_t * object_keyletters, c_t * s )
{
  fprintf( stderr, "UserEmptyHandleDetectedCallout %s %s.\n", object_keyletters, s );
}

/*
 * UserObjectPoolEmptyCallout
 *
 * This function is invoked when an attempt is made to create an
 * instance of an object, but there are no instances available.
 */
void
UserObjectPoolEmptyCalloutf( const Escher_DomainNumber_t component_number, const Escher_ClassNumber_t class_number )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserObjectPoolEmptyCallout\n" )
}

/*
 * UserNodeListEmptyCallout
 *
 * This function is invoked when an attempt is made to allocate a
 * node, but there are no more left.
 */
void
UserNodeListEmptyCalloutf( void )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserNodeListEmptyCallout\n" )
}

/*
 * UserInterleavedBridgeOverflowCallout
 *
 * This function is invoked when an attempt is made to post too many
 * interleaved bridges.  The depth of this list is defined by
 * SYS_MAX_INTERLEAVED_BRIDGES (unless changed in the archetype).
 */
void
UserInterleavedBridgeOverflowCalloutf( void )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserInterleavedBridgeOverflowCallout\n" )
}

/*
 * UserSelfEventQueueEmptyCallout
 *
 * This function is invoked when the events to self queue is
 * interrogated and found to be empty.
 */
void
UserSelfEventQueueEmptyCalloutf( void )
{
  /* Insert implementation specific code here.  */
}

/*
 * UserNonSelfEventQueueEmptyCallout
 *
 * This function is invoked when the events to instance queue is
 * interrogated and found to be empty.
 */
void
UserNonSelfEventQueueEmptyCalloutf( void )
{
  /* Insert implementation specific code here.  */
}

/*
 * UserPersistenceErrorCallout
 *
 * This function is invoked when the events to instance queue is
 * interrogated and found to be empty.
 */
void
UserPersistenceErrorCalloutf( i_t error_code )
{
  /* Insert implementation specific code here.  */
  SYS_USER_CO_PRINTF( "UserPersistenceErrorCallout\n" )
}
